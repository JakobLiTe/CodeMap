<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Mini Starfox</title>
    <style>
        body {
            margin: 0;
            background: black; 
            overflow: hidden;
        }
        canvas {
            display: block;      
        }
    </style>
</head>
<body>
<canvas id="game"></canvas>

<audio id="bgm"      src="bgm.wav" loop></audio>
<audio id="startSfx" src="game_start.wav"></audio>
<audio id="deathSfx" src="death.wav"></audio>
<audio id="hitSfx"   src="hit.ogg"></audio>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let obstacles = [];
let spwnT = 0;
let playerX = 0;
let playerY = -0.2;
let tilt = 0;
let lives = 3;
let isDead = false;
let dT = 0;
let score = 0;

const bgm      = document.getElementById("bgm");
const startSfx = document.getElementById("startSfx");
const deathSfx = document.getElementById("deathSfx");
const hitSfx   = document.getElementById("hitSfx");

bgm.volume = 0.8;

let gameOver = false;

let firstPlay = false;

window.addEventListener("keydown", () => {
    if (!firstPlay) {
        firstPlay = true;
        bgm.play().catch(()=>{});
        startSfx.play().catch(()=>{});
    }
});

function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;
    
}
resize();
window.addEventListener("resize", resize);
let keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

window.addEventListener("keydown", e => {
    if (e.key === "m" || e.key === "M") {
        bgm.muted = !bgm.muted;
        startSfx.muted = bgm.muted;
        deathSfx.muted = bgm.muted;
        hitSfx.muted = bgm.muted;
    }
});

function spawnObstacle() {
    let zone = Math.random();

    let xVal;
    if (zone < 0.5) {
        xVal = (Math.random() - 0.5) * 1.6;
    } else {
        xVal = (Math.random() < 0.5 ? -1.5 : 1.5) + (Math.random() * 0.4 - 0.2);
    }

    obstacles.push({
        x: xVal,
        z: 8 + Math.random() * 1,
        size: 0.2 + Math.random() * 0.15,
        height: 0.7 + Math.random() * 1.0,
        drift: (Math.random() - 0.5) * 0.01
    });
}

if (bgm.paused) {
    bgm.play().catch(()=>{});
    startSfx.play().catch(()=>{});
}

function update() {
  if (gameOver) return;
  if (isDead) {
    dT -= 0.03;
    if (dT <= 0) {
        isDead = false;
        playerX = 0;
        playerY = -0.2;
        tilt = 0;
    } else {
        return;
    }
}
score += 1;
  let speed = 0.04;

if (keys["ArrowLeft"])  { playerX -= speed; tilt = -0.3; }
if (keys["ArrowRight"]) { playerX += speed; tilt = 0.3;  }
if (keys["ArrowUp"])    { playerY -= speed; }
if (keys["ArrowDown"])  { playerY += speed; }

if (!keys["ArrowLeft"] && !keys["ArrowRight"]) {
    tilt *= 0.8;
}

if (playerX < -1.6) playerX = -1.6;
if (playerX >  1.6) playerX = 1.6;
if (playerY < -0.5) playerY = -0.5;
if (playerY >  0.4) playerY = 0.4;

    obstacles.forEach(o => {
        o.z -= 0.04;
        o.x += o.drift;
    });

    obstacles = obstacles.filter(o => o.z > 0.3);

    obstacles.forEach(o => {
    if (o.z < 1.4 && o.z > 0.8) {
        if (Math.abs(o.x - playerX) < o.size + 0.12 && playerY > 0.5 - o.height - 0.05) {
           hitSfx.play().catch(()=>{});

            lives--;
            isDead = true;
            dT = 0.8;

            if (lives <= 0) {
               deathSfx.play().catch(()=>{});
               gameOver = true;
            }
        }
    }
});

    spwnT -= 0.03;

    if (spwnT <= 0) {
        spawnObstacle();
        spwnT = 0.6 + Math.random() * 1.2;
    }
}

function drawGroundGrid() {
    ctx.strokeStyle = "cyan";

    for (let x = -8; x <= 8; x += 0.4) {
        line3D(x, 0.5, 1, x, 0.5, 14);
    }

    for (let z = 1; z <= 14; z += 0.5) {
        line3D(-8, 0.5, z, 8, 0.5, z);
    }
}

function drawObstacle(o) {
    let w = o.size;   
    let h = o.height; 
    let z = o.z;
    line3D(o.x - w, 0.5, z, o.x + w, 0.5, z);
    line3D(o.x - w, 0.5 - h, z, o.x + w, 0.5 - h, z);
    line3D(o.x - w, 0.5, z, o.x - w, 0.5 - h, z);
    line3D(o.x + w, 0.5, z, o.x + w, 0.5 - h, z);
}

function drawShip() {
    let z = 1;
    let px = playerX;
    let py = playerY;
    let angle = tilt;
    function rot(x, y) {
        return {
            x: px + (x * Math.cos(angle) - y * Math.sin(angle)),
            y: py + (x * Math.sin(angle) + y * Math.cos(angle))
        };
    }
    let nose      = rot(0,   -0.28);
    let cockpit   = rot(0,   -0.14);
    let bodyL     = rot(-0.10, 0.00);
    let bodyR     = rot( 0.10, 0.00);
    let tailL     = rot(-0.08, 0.20);
    let tailR     = rot( 0.08, 0.20);
    let wingL     = rot(-0.55, 0.06);
    let wingR     = rot( 0.55, 0.06);
    let P = {};
    function Pp(n,p){ P[n]=proj(p.x,p.y,z); }
    Pp("nose",nose);
    Pp("cockpit",cockpit);
    Pp("bodyL",bodyL);
    Pp("bodyR",bodyR);
    Pp("tailL",tailL);
    Pp("tailR",tailR);
    Pp("wingL",wingL);
    Pp("wingR",wingR);
    ctx.fillStyle="black";
    ctx.beginPath();
    ctx.moveTo(P.nose.x, P.nose.y);
    ctx.lineTo(P.bodyL.x, P.bodyL.y);
    ctx.lineTo(P.tailL.x, P.tailL.y);
    ctx.lineTo(P.tailR.x, P.tailR.y);
    ctx.lineTo(P.bodyR.x, P.bodyR.y);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(P.bodyL.x, P.bodyL.y);
    ctx.lineTo(P.wingL.x, P.wingL.y);
    ctx.lineTo(P.tailL.x, P.tailL.y);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(P.bodyR.x, P.bodyR.y);
    ctx.lineTo(P.wingR.x, P.wingR.y);
    ctx.lineTo(P.tailR.x, P.tailR.y);
    ctx.closePath();
    ctx.fill();
    function L(a,b){ line3D(a.x,a.y,z,b.x,b.y,z); }
    L(nose, cockpit);
    L(cockpit, bodyL);
    L(cockpit, bodyR);
    L(bodyL, tailL);
    L(bodyR, tailR);
    L(tailL, tailR);
    L(bodyL, wingL);
    L(bodyR, wingR);
}

function drawMountains() {
    ctx.strokeStyle = "cyan";
    ctx.lineWidth = 3;
    const horizonY = -0.8;
    const mx = [-10, -6, -3, 0, 2, 5, 9];
    const my = [-0.4, -1.2, -0.5, -2.0, -0.7, -1.5, -0.3];
    ctx.beginPath();
    for (let i = 0; i < mx.length; i++) {
        const p = proj(mx[i], horizonY + my[i], 3.2);
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
    }
    ctx.stroke();
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textAlign = "left";
    ctx.fillStyle = "cyan";
    ctx.font = "24px monospace";
    ctx.fillText("Lives: " + lives, 20, 40);
    ctx.fillText("Score: " + score, 20, 70);
    drawGroundGrid();
    drawMountains();
    drawShip();
    obstacles.forEach(drawObstacle);
    if (gameOver) {
        ctx.fillStyle = "cyan";
        ctx.font = "60px monospace";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
        return;
    }
}
function proj(x, y, z) {
    let f = 300;                
    let scale = f / z;        
    return {
        x: canvas.width / 2 + x * scale,
        y: canvas.height / 1.3 + y * scale
    };
}
function line3D(x1, y1, z1, x2, y2, z2) {
   let a = proj(x1, y1, z1);
    let b = proj(x2, y2, z2);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
}

function loop() {
    update();
    render();
    requestAnimationFrame(loop); 
}
loop();
</script>
</body>
</html>