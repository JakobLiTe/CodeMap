<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>nieo fly og s√•nt</title>
    <style>
        body {
            margin: 0;
            background: black; 
            overflow: hidden;
        }
        canvas {
            display: block;      
        }
    </style>
</head>
<body>
<canvas id="game"></canvas>

<audio id="bgm"      src="bgm.wav" loop></audio>
<audio id="startSfx" src="game_start.wav"></audio>
<audio id="deathSfx" src="death.wav"></audio>
<audio id="hitSfx"   src="hit.ogg"></audio>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const staticCanvas = document.createElement("canvas");
const staticCtx = staticCanvas.getContext("2d");
let obstacles = [];
let spwnT = 0;
let playerX = 0;
let playerY = 0.1;
let tilt = 0;
let lives = 3;
let isDead = false;
let dT = 0;
let score = 0;
let shipZ = 1.2;
let invuln = 0;

const bgm      = document.getElementById("bgm");
const startSfx = document.getElementById("startSfx");
const deathSfx = document.getElementById("deathSfx");
const hitSfx   = document.getElementById("hitSfx");

bgm.volume = 0.8;

let gameOver = false;
let firstPlay = false;

window.addEventListener("keydown", () => {
    if (!firstPlay) {
        firstPlay = true;
        bgm.play().catch(()=>{});
        startSfx.play().catch(()=>{});
        playerY = 0.1;
    }
});

function resize() {
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight;

    staticCanvas.width = canvas.width;
    staticCanvas.height = canvas.height;

    buildStaticScene();
}

function buildStaticScene() {
    staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);
    staticCtx.strokeStyle = "cyan";
    staticCtx.lineWidth = 1;

    // ground grid
    staticCtx.beginPath();
    for (let x = -8; x <= 8; x += 0.7) {
        line3DTo(staticCtx, x, 0.5, 1, x, 0.5, 14);
    }
    for (let z = 1; z <= 14; z += 1.0) {
        line3DTo(staticCtx, -8, 0.5, z, 8, 0.5, z);
    }
    staticCtx.stroke();

    // mountains
    staticCtx.lineWidth = 3;
    const horizonY = -0.8;
    const mx = [-10, -6, -3, 0, 2, 5, 9];
    const my = [-0.4, -1.2, -0.5, -2.0, -0.7, -1.5, -0.3];
    staticCtx.beginPath();
    for (let i = 0; i < mx.length; i++) {
        const p = proj(mx[i], horizonY + my[i], 3.2);
        if (i === 0) staticCtx.moveTo(p.x, p.y);
        else staticCtx.lineTo(p.x, p.y);
    }
    staticCtx.stroke();
}

resize();
window.addEventListener("resize", resize);
let keys = {};
window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

window.addEventListener("keydown", e => {
    if (e.key === "m" || e.key === "M") {
        bgm.muted = !bgm.muted;
        startSfx.muted = bgm.muted;
        deathSfx.muted = bgm.muted;
        hitSfx.muted = bgm.muted;
    }
});

function spawnObstacle() {
    let zone = Math.random();
    let xVal;
    if (zone < 0.5) {
        xVal = (Math.random() - 0.5) * 1.6;
    } else {
        xVal = (Math.random() < 0.5 ? -1.5 : 1.5) + (Math.random() * 0.4 - 0.2);
    }
    obstacles.push({
        x: xVal,
        z: 8 + Math.random() * 1,
        size: 0.2 + Math.random() * 0.15,
        height: 0.7 + Math.random() * 1.0,
        drift: (Math.random() - 0.5) * 0.01
    });
}

if (bgm.paused) {
    bgm.play().catch(()=>{});
    startSfx.play().catch(()=>{});
}

function update() {
  if (gameOver) return;
  if (invuln > 0) {
      invuln -= 0.03;
  }
  if (isDead) {
    dT -= 0.03;
    if (dT <= 0) {
        isDead = false;
    }
  }
  score += 1;
  let speed = 0.04;

  if (keys["ArrowLeft"])  { playerX -= speed; tilt = -0.3; }
  if (keys["ArrowRight"]) { playerX += speed; tilt = 0.3;  }


  if (!keys["ArrowLeft"] && !keys["ArrowRight"]) {
      tilt *= 0.8;
  }

  if (playerX < -1.6) playerX = -1.6;
  if (playerX >  1.6) playerX = 1.6;
  if (playerY < -0.5) playerY = -0.5;
  if (playerY >  0.4) playerY = 0.4;

  obstacles.forEach(o => {
      o.z -= 0.04;
      o.x += o.drift;
  });

  obstacles = obstacles.filter(o => o.z > 0.3);

  obstacles.forEach(o => {
    if (o.z < 1.4 && o.z > 0.8) {
        if (invuln <= 0 && Math.abs(o.x - playerX) < o.size + 0.12 && playerY > 0.5 - o.height - 0.05) {
           hitSfx.currentTime = 0;
           hitSfx.play().catch(()=>{});
            lives--;
            isDead = true;
            invuln = 0.8;
            dT = 0.8;
            playerY = 0.1;
            if (lives <= 0) {
               deathSfx.play().catch(()=>{});
               gameOver = true;
            }
        }
    }
  });

  spwnT -= 0.03;
  if (spwnT <= 0) {
      spawnObstacle();
      spwnT = 0.6 + Math.random() * 1.2;
  }
}

function drawGroundGrid() {}

function drawObstacle(o) {
    let w = o.size;   
    let h = o.height; 
    let z = o.z;
    line3D(o.x - w, 0.5, z, o.x + w, 0.5, z);
    line3D(o.x - w, 0.5 - h, z, o.x + w, 0.5 - h, z);
    line3D(o.x - w, 0.5, z, o.x - w, 0.5 - h, z);
    line3D(o.x + w, 0.5, z, o.x + w, 0.5 - h, z);
}

function drawShip() {
    let z = shipZ;
    let px = playerX;
    let py = playerY;
    let angle = tilt * 0.6;

    function rot(x, y) {
        return {
            x: px + (x * Math.cos(angle) - y * Math.sin(angle)),
            y: py + (x * Math.sin(angle) + y * Math.cos(angle))
        };
    }

    let pts = {
        nose:    rot(0, -0.28),
        cockpit: rot(0, -0.14),
        bodyL:   rot(-0.10, 0.00),
        bodyR:   rot( 0.10, 0.00),
        tailL:   rot(-0.08, 0.20),
        tailR:   rot( 0.08, 0.20),
        wingL:   rot(-0.55, 0.06),
        wingR:   rot( 0.55, 0.06)
    };

    for (let k in pts) pts[k] = projShip(pts[k].x, pts[k].y, z);

    ctx.beginPath();
    ctx.moveTo(pts.nose.x, pts.nose.y);
    ctx.lineTo(pts.bodyL.x, pts.bodyL.y);
    ctx.lineTo(pts.tailL.x, pts.tailL.y);
    ctx.lineTo(pts.tailR.x, pts.tailR.y);
    ctx.lineTo(pts.bodyR.x, pts.bodyR.y);
    ctx.closePath();
    ctx.fillStyle = "black";
    ctx.fill();
    ctx.strokeStyle = "cyan";
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(pts.bodyL.x, pts.bodyL.y);
    ctx.lineTo(pts.wingL.x, pts.wingL.y);
    ctx.lineTo(pts.tailL.x, pts.tailL.y);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(pts.bodyR.x, pts.bodyR.y);
    ctx.lineTo(pts.wingR.x, pts.wingR.y);
    ctx.lineTo(pts.tailR.x, pts.tailR.y);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(pts.bodyL.x, pts.bodyL.y);
    ctx.lineTo(pts.wingL.x, pts.wingL.y);
    ctx.lineTo(pts.tailL.x, pts.tailL.y);
    ctx.closePath();
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(pts.bodyR.x, pts.bodyR.y);
    ctx.lineTo(pts.wingR.x, pts.wingR.y);
    ctx.lineTo(pts.tailR.x, pts.tailR.y);
    ctx.closePath();
    ctx.stroke();

    function L(a, b) {
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(b.x, b.y);
        ctx.stroke();
    }

    L(pts.nose, pts.cockpit);
    L(pts.cockpit, pts.bodyL);
    L(pts.cockpit, pts.bodyR);
    L(pts.bodyL, pts.tailL);
    L(pts.bodyR, pts.tailR);
    L(pts.tailL, pts.tailR);
    L(pts.bodyL, pts.wingL);
    L(pts.bodyR, pts.wingR);
}

function drawMountains() {}

function line3DTo(c, x1, y1, z1, x2, y2, z2) {
    const a = proj(x1, y1, z1);
    const b = proj(x2, y2, z2);
    c.moveTo(a.x, a.y);
    c.lineTo(b.x, b.y);
}

function proj(x, y, z) {
    let f = 300;                
    let scale = f / z;        
    return {
        x: canvas.width / 2 + x * scale,
        y: canvas.height / 1.38 + y * scale
    };
}
function projShip(x, y, z) {
    const f = 300;
    const scale = f / z;
    return {
        x: canvas.width / 2 + x * scale,
        y: canvas.height * 0.80 + y * scale
    };
}
function line3D(x1, y1, z1, x2, y2, z2) {
   let a = proj(x1, y1, z1);
    let b = proj(x2, y2, z2);
    ctx.beginPath();
    ctx.moveTo(a.x, a.y);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();
}

function render() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.textAlign = "left";
    ctx.fillStyle = "cyan";
    ctx.font = "24px monospace";
    ctx.fillText("Lives: " + lives, 20, 40);
    ctx.fillText("Score: " + score, 20, 70);
    ctx.drawImage(staticCanvas, 0, 0);
    drawShip();
    obstacles.forEach(drawObstacle);
    if (gameOver) {
        ctx.fillStyle = "cyan";
        ctx.font = "60px monospace";
        ctx.textAlign = "center";
        ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);
        return;
    }
}
function loop() {
    update();
    render();
    requestAnimationFrame(loop); 
}
loop();
</script>
</body>
</html>